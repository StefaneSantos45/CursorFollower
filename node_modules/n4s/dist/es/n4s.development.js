import { bindNot, isStringValue, numberEquals, greaterThan, isArray, isNumeric, isNullish, isBoolean, isEmpty, isNotArray, isNotEmpty, isNotNull, isNotNullish, isNotNumeric, isNotUndefined, isNull, isPositive, isUndefined, lengthEquals, lengthNotEquals, longerThan, numberNotEquals, isFunction, assign, defaultTo, optionalFunctionValue, invariant, StringObject, mapFirst } from 'vest-utils';
import { createCascade } from 'context';

function endsWith(value, arg1) {
    return isStringValue(value) && isStringValue(arg1) && value.endsWith(arg1);
}
var doesNotEndWith = bindNot(endsWith);

function equals(value, arg1) {
    return value === arg1;
}
var notEquals = bindNot(equals);

function greaterThanOrEquals(value, gte) {
    return numberEquals(value, gte) || greaterThan(value, gte);
}

function inside(value, arg1) {
    if (isArray(arg1)) {
        return arg1.indexOf(value) !== -1;
    }
    // both value and arg1 are strings
    if (isStringValue(arg1) && isStringValue(value)) {
        return arg1.indexOf(value) !== -1;
    }
    return false;
}
var notInside = bindNot(inside);

function lessThan(value, lt) {
    return isNumeric(value) && isNumeric(lt) && Number(value) < Number(lt);
}

function lessThanOrEquals(value, lte) {
    return numberEquals(value, lte) || lessThan(value, lte);
}

function isBetween(value, min, max) {
    return greaterThanOrEquals(value, min) && lessThanOrEquals(value, max);
}
var isNotBetween = bindNot(isBetween);

function isBlank(value) {
    return isNullish(value) || (isStringValue(value) && !value.trim());
}
var isNotBlank = bindNot(isBlank);

var isNotBoolean = bindNot(isBoolean);

/**
 * Validates that a given value is an even number
 */
var isEven = function (value) {
    if (isNumeric(value)) {
        return value % 2 === 0;
    }
    return false;
};

function isKeyOf(key, obj) {
    return key in obj;
}
var isNotKeyOf = bindNot(isKeyOf);

function isNaN(value) {
    return Number.isNaN(value);
}
var isNotNaN = bindNot(isNaN);

function isNegative(value) {
    return lessThan(value, 0);
}

function isNumber(value) {
    return Boolean(typeof value === 'number');
}
var isNotNumber = bindNot(isNumber);

/**
 * Validates that a given value is an odd number
 */
var isOdd = function (value) {
    if (isNumeric(value)) {
        return value % 2 !== 0;
    }
    return false;
};

var isNotString = bindNot(isStringValue);

function isTruthy(value) {
    return !!value;
}
var isFalsy = bindNot(isTruthy);

function isValueOf(value, objectToCheck) {
    if (isNullish(objectToCheck)) {
        return false;
    }
    for (var key in objectToCheck) {
        if (objectToCheck[key] === value) {
            return true;
        }
    }
    return false;
}
var isNotValueOf = bindNot(isValueOf);

function longerThanOrEquals(value, arg1) {
    return greaterThanOrEquals(value.length, arg1);
}

function matches(value, regex) {
    if (regex instanceof RegExp) {
        return regex.test(value);
    }
    else if (isStringValue(regex)) {
        return new RegExp(regex).test(value);
    }
    return false;
}
var notMatches = bindNot(matches);

function condition(value, callback) {
    try {
        return callback(value);
    }
    catch (_a) {
        return false;
    }
}

function shorterThan(value, arg1) {
    return lessThan(value.length, arg1);
}

function shorterThanOrEquals(value, arg1) {
    return lessThanOrEquals(value.length, arg1);
}

function startsWith(value, arg1) {
    return isStringValue(value) && isStringValue(arg1) && value.startsWith(arg1);
}
var doesNotStartWith = bindNot(startsWith);

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, max-lines-per-function
function rules() {
    return {
        condition: condition,
        doesNotEndWith: doesNotEndWith,
        doesNotStartWith: doesNotStartWith,
        endsWith: endsWith,
        equals: equals,
        greaterThan: greaterThan,
        greaterThanOrEquals: greaterThanOrEquals,
        gt: greaterThan,
        gte: greaterThanOrEquals,
        inside: inside,
        isArray: isArray,
        isBetween: isBetween,
        isBlank: isBlank,
        isBoolean: isBoolean,
        isEmpty: isEmpty,
        isEven: isEven,
        isFalsy: isFalsy,
        isKeyOf: isKeyOf,
        isNaN: isNaN,
        isNegative: isNegative,
        isNotArray: isNotArray,
        isNotBetween: isNotBetween,
        isNotBlank: isNotBlank,
        isNotBoolean: isNotBoolean,
        isNotEmpty: isNotEmpty,
        isNotKeyOf: isNotKeyOf,
        isNotNaN: isNotNaN,
        isNotNull: isNotNull,
        isNotNullish: isNotNullish,
        isNotNumber: isNotNumber,
        isNotNumeric: isNotNumeric,
        isNotString: isNotString,
        isNotUndefined: isNotUndefined,
        isNotValueOf: isNotValueOf,
        isNull: isNull,
        isNullish: isNullish,
        isNumber: isNumber,
        isNumeric: isNumeric,
        isOdd: isOdd,
        isPositive: isPositive,
        isString: isStringValue,
        isTruthy: isTruthy,
        isUndefined: isUndefined,
        isValueOf: isValueOf,
        lengthEquals: lengthEquals,
        lengthNotEquals: lengthNotEquals,
        lessThan: lessThan,
        lessThanOrEquals: lessThanOrEquals,
        longerThan: longerThan,
        longerThanOrEquals: longerThanOrEquals,
        lt: lessThan,
        lte: lessThanOrEquals,
        matches: matches,
        notEquals: notEquals,
        notInside: notInside,
        notMatches: notMatches,
        numberEquals: numberEquals,
        numberNotEquals: numberNotEquals,
        shorterThan: shorterThan,
        shorterThanOrEquals: shorterThanOrEquals,
        startsWith: startsWith
    };
}

var baseRules = rules();
function getRule(ruleName) {
    return baseRules[ruleName];
}

function eachEnforceRule(action) {
    for (var ruleName in baseRules) {
        var ruleFn = getRule(ruleName);
        if (isFunction(ruleFn)) {
            action(ruleName, ruleFn);
        }
    }
}

var ctx = createCascade(function (ctxRef, parentContext) {
    var base = {
        value: ctxRef.value,
        meta: ctxRef.meta || {}
    };
    if (!parentContext) {
        return assign(base, {
            parent: emptyParent
        });
    }
    else if (ctxRef.set) {
        return assign(base, {
            parent: function () { return stripContext(parentContext); }
        });
    }
    return parentContext;
});
function stripContext(ctx) {
    if (!ctx) {
        return null;
    }
    return {
        value: ctx.value,
        meta: ctx.meta,
        parent: ctx.parent
    };
}
function emptyParent() {
    return null;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function isProxySupported() {
    try {
        return isFunction(Proxy);
    }
    catch (_a) {
        return false;
    }
}

function ruleReturn(pass, message) {
    var output = { pass: pass };
    if (message) {
        output.message = message;
    }
    return output;
}
function passing() {
    return ruleReturn(true);
}
function defaultToPassing(callback) {
    return defaultTo(callback, passing());
}

/**
 * Transform the result of a rule into a standard format
 */
function transformResult(result, ruleName, value) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    validateResult(result);
    // if result is boolean
    if (isBoolean(result)) {
        return ruleReturn(result);
    }
    return ruleReturn(result.pass, optionalFunctionValue.apply(void 0, __spreadArray([result.message, ruleName, value], args, false)));
}
function validateResult(result) {
    // if result is boolean, or if result.pass is boolean
    invariant(isBoolean(result) || (result && isBoolean(result.pass)), 'Incorrect return value for rule: ' + JSON.stringify(result));
}

// eslint-disable-next-line max-lines-per-function
function enforceEager(value) {
    var target = {
        message: message
    };
    var customMessage = undefined;
    // This condition is for when we don't have proxy support (ES5).
    // In this case, we need to manually assign the rules to the target object on runtime.
    // The follow up proxy block is used in case we do have proxy support, and we can assign each rule upon invocation.
    if (!isProxySupported()) {
        // We iterate over each of the rules, and add them to the target object being return by enforce
        eachEnforceRule(function (ruleName, ruleFn) {
            // We then wrap the rule with `genRuleCall` that adds the base enforce behavior
            target[ruleName] = genRuleCall(target, ruleFn, ruleName);
        });
        return target;
    }
    // We create a proxy intercepting access to the target object (which is empty).
    var proxy = new Proxy(target, {
        get: function (_, key) {
            // On property access, we identify if it is a rule or not.
            var rule = getRule(key);
            // If it is a rule, we wrap it with `genRuleCall` that adds the base enforce behavior
            if (rule) {
                return genRuleCall(proxy, rule, key);
            }
            return target[key];
        }
    });
    return proxy;
    // This function is used to wrap a rule with the base enforce behavior
    // It takes the target object, the rule function, and the rule name
    // It then returns the rule, in a manner that can be used by enforce
    function genRuleCall(target, rule, ruleName) {
        return function ruleCall() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // Order of operation:
            // 1. Create a context with the value being enforced
            // 2. Call the rule within the context, and pass over the arguments passed to it
            // 3. Transform the result to the correct output format
            var transformedResult = ctx.run({ value: value }, function () {
                return transformResult.apply(void 0, __spreadArray([rule.apply(void 0, __spreadArray([value], args, false)), ruleName, value], args, false));
            });
            function enforceMessage() {
                if (!isNullish(customMessage))
                    return StringObject(customMessage);
                if (isNullish(transformedResult.message)) {
                    return "enforce/".concat(ruleName, " failed with ").concat(JSON.stringify(value));
                }
                return StringObject(transformedResult.message);
            }
            // On rule failure (the result is false), we either throw an error
            // or throw a string value if the rule has a message defined in it.
            invariant(transformedResult.pass, enforceMessage());
            return target;
        };
    }
    function message(input) {
        customMessage = input;
        return proxy;
    }
}

// eslint-disable-next-line max-lines-per-function
function genEnforceLazy(key) {
    var registeredRules = [];
    var lazyMessage;
    return addLazyRule(key);
    // eslint-disable-next-line max-lines-per-function
    function addLazyRule(ruleName) {
        // eslint-disable-next-line max-lines-per-function
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var rule = getRule(ruleName);
            registeredRules.push(function (value) {
                return transformResult.apply(void 0, __spreadArray([rule.apply(void 0, __spreadArray([value], args, false)), ruleName, value], args, false));
            });
            var proxy = {
                run: function (value) {
                    return defaultToPassing(mapFirst(registeredRules, function (rule, breakout) {
                        var _a;
                        var res = ctx.run({ value: value }, function () { return rule(value); });
                        breakout(!res.pass, ruleReturn(!!res.pass, (_a = optionalFunctionValue(lazyMessage, value, res.message)) !== null && _a !== void 0 ? _a : res.message));
                    }));
                },
                test: function (value) { return proxy.run(value).pass; },
                message: function (message) {
                    if (message) {
                        lazyMessage = message;
                    }
                    return proxy;
                }
            };
            if (!isProxySupported()) {
                eachEnforceRule(function (ruleName) {
                    proxy[ruleName] = addLazyRule(ruleName);
                });
                return proxy;
            }
            // reassigning the proxy here is not pretty
            // but it's a cleaner way of getting `run` and `test` for free
            proxy = new Proxy(proxy, {
                get: function (target, key) {
                    if (getRule(key)) {
                        return addLazyRule(key);
                    }
                    return target[key]; // already has `run` and `test` on it
                }
            });
            return proxy;
        };
    }
}

/**
 * Enforce is quite complicated, I want to explain it in detail.
 * It is dynamic in nature, so a lot of proxy objects are involved.
 *
 * Enforce has two main interfaces
 * 1. eager
 * 2. lazy
 *
 * The eager interface is the most commonly used, and the easier to understand.
 * It throws an error when a rule is not satisfied.
 * The eager interface is declared in enforceEager.ts and it is quite simple to understand.
 * enforce is called with a value, and the return value is a proxy object that points back to all the rules.
 * When a rule is called, the value is mapped as its first argument, and if the rule passes, the same
 * proxy object is returned. Otherwise, an error is thrown.
 *
 * The lazy interface works quite differently. It is declared in genEnforceLazy.ts.
 * Rather than calling enforce directly, the lazy interface has all the rules as "methods" (only by proxy).
 * Calling the first function in the chain will initialize an array of calls. It stores the different rule calls
 * and the parameters passed to them. None of the rules are called yet.
 * The rules are only invoked in sequence once either of these chained functions are called:
 * 1. test(value)
 * 2. run(value)
 *
 * Calling run or test will call all the rules in sequence, with the difference that test will only return a boolean value,
 * while run will return an object with the validation result and an optional message created by the rule.
 */
function genEnforce() {
    var target = {
        context: function () { return ctx.useX(); },
        extend: function (customRules) {
            assign(baseRules, customRules);
            handleNoProxy(); // TODO: REMOVE when we stop supporting ES5
        }
    };
    handleNoProxy();
    return new Proxy(assign(enforceEager, target), {
        get: function (target, key) {
            if (key in target) {
                return target[key];
            }
            if (!getRule(key)) {
                return;
            }
            // Only on the first rule access - start the chain of calls
            return genEnforceLazy(key);
        }
    });
    function handleNoProxy() {
        if (!isProxySupported()) {
            eachEnforceRule(function (ruleName) {
                // Only on the first rule access - start the chain of calls
                target[ruleName] = genEnforceLazy(ruleName);
            });
            return assign(enforceEager, target);
        }
    }
}
var enforce = genEnforce();

export { ctx, enforce };
