import { defaultTo, mapFirst, isNullish, hasOwnProperty } from 'vest-utils';
import { ctx, enforce } from 'n4s';

function ruleReturn(pass, message) {
    var output = { pass: pass };
    if (message) {
        output.message = message;
    }
    return output;
}
function failing() {
    return ruleReturn(false);
}
function passing() {
    return ruleReturn(true);
}
function defaultToPassing(callback) {
    return defaultTo(callback, passing());
}

function runLazyRule(lazyRule, currentValue) {
    try {
        return lazyRule.run(currentValue);
    }
    catch (_a) {
        return failing();
    }
}

function isArrayOf(inputArray, currentRule) {
    return defaultToPassing(mapFirst(inputArray, function (currentValue, breakout, index) {
        var res = ctx.run({ value: currentValue, set: true, meta: { index: index } }, function () { return runLazyRule(currentRule, currentValue); });
        breakout(!res.pass, res);
    }));
}

function loose(inputObject, shapeObject) {
    var _loop_1 = function (key) {
        var currentValue = inputObject[key];
        var currentRule = shapeObject[key];
        var res = ctx.run({ value: currentValue, set: true, meta: { key: key } }, function () {
            return runLazyRule(currentRule, currentValue);
        });
        if (!res.pass) {
            return { value: res };
        }
    };
    for (var key in shapeObject) {
        var state_1 = _loop_1(key);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return passing();
}

function optional(value, ruleChain) {
    if (isNullish(value)) {
        return passing();
    }
    return runLazyRule(ruleChain, value);
}

function shape(inputObject, shapeObject) {
    var baseRes = loose(inputObject, shapeObject);
    if (!baseRes.pass) {
        return baseRes;
    }
    for (var key in inputObject) {
        if (!hasOwnProperty(shapeObject, key)) {
            return failing();
        }
    }
    return passing();
}

// Help needed improving the typings of this file.
// Ideally, we'd be able to extend ShapeObject, but that's not possible.
function partial(shapeObject) {
    var output = {};
    for (var key in shapeObject) {
        output[key] = enforce.optional(shapeObject[key]);
    }
    return output;
}

enforce.extend({ isArrayOf: isArrayOf, loose: loose, optional: optional, shape: shape });

export { partial };
