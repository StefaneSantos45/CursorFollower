import { enforce } from 'n4s';
import { CB, nestedArray } from "vest-utils";
import { UseState } from "vast";
type SuiteSummary = {
    groups: Groups;
    tests: Tests;
    valid: boolean;
} & SummaryBase;
type GroupTestSummary = SingleTestSummary;
type Groups = Record<string, Group>;
type Group = Record<string, GroupTestSummary>;
type Tests = Record<string, SingleTestSummary>;
type SingleTestSummary = SummaryBase & {
    errors: string[];
    warnings: string[];
    valid: boolean;
};
type SummaryBase = {
    errorCount: number;
    warnCount: number;
    testCount: number;
};
type FailureMessages = Record<string, string[]>;
declare enum TestSeverity {
    Error = "error",
    Warning = "warning"
}
declare class VestTest {
    fieldName: string;
    testFn: TestFn;
    asyncTest?: AsyncTest;
    groupName?: string;
    message?: string;
    key?: null | string;
    id: string;
    severity: TestSeverity;
    status: KStatus;
    constructor(fieldName: string, testFn: TestFn, { message, groupName, key }?: {
        message?: string;
        groupName?: string;
        key?: string;
    });
    run(): TestResult;
    setStatus(status: KStatus): void;
    warns(): boolean;
    setPending(): void;
    fail(): void;
    done(): void;
    warn(): void;
    isFinalStatus(): boolean;
    skip(force?: boolean): void;
    cancel(): void;
    reset(): void;
    omit(): void;
    valueOf(): boolean;
    isPending(): boolean;
    isOmitted(): boolean;
    isUntested(): boolean;
    isFailing(): boolean;
    isCanceled(): boolean;
    isSkipped(): boolean;
    isPassing(): boolean;
    isWarning(): boolean;
    hasFailures(): boolean;
    isNonActionable(): boolean;
    isTested(): boolean;
    awaitsResolution(): boolean;
    statusEquals(status: KStatus): boolean;
}
type AsyncTest = Promise<string | void>;
type TestResult = AsyncTest | boolean | void;
type TestFn = () => TestResult;
type KStatus = "UNTESTED" | "SKIPPED" | "FAILED" | "WARNING" | "PASSING" | "PENDING" | "CANCELED" | "OMITTED";
// eslint-disable-next-line max-lines-per-function, max-statements
declare function suiteSelectors(summary: SuiteSummary): SuiteSelectors;
interface SuiteSelectors {
    getErrors(fieldName: string): string[];
    getErrors(): FailureMessages;
    getWarnings(): FailureMessages;
    getWarnings(fieldName: string): string[];
    getErrorsByGroup(groupName: string, fieldName: string): string[];
    getErrorsByGroup(groupName: string): FailureMessages;
    getWarningsByGroup(groupName: string): FailureMessages;
    getWarningsByGroup(groupName: string, fieldName: string): string[];
    hasErrors(fieldName?: string): boolean;
    hasWarnings(fieldName?: string): boolean;
    hasErrorsByGroup(groupName: string, fieldName?: string): boolean;
    hasWarningsByGroup(groupName: string, fieldName?: string): boolean;
    isValid(fieldName?: string): boolean;
    isValidByGroup(groupName: string, fieldName?: string): boolean;
}
type SuiteResult = SuiteSummary & SuiteSelectors & {
    suiteName: SuiteName;
};
type SuiteRunResult = SuiteResult & {
    done: Done;
};
interface Done {
    (...args: [
        cb: (res: SuiteResult) => void
    ]): SuiteRunResult;
    (...args: [
        fieldName: string,
        cb: (res: SuiteResult) => void
    ]): SuiteRunResult;
}
/**
 * Creates a new validation suite
 *
 * @example
 *
 * const suite = create((data = {}) => {
 *  test("username", "Username is required", () => {
 *    enforce(data.username).isNotBlank();
 *  });
 * });
 */
declare function create<T extends CB>(suiteName: SuiteName, suiteCallback: T): Suite<T>;
declare function create<T extends CB>(suiteCallback: T): Suite<T>;
type SuiteName = string | void;
type Suite<T extends CB> = {
    (...args: Parameters<T>): SuiteRunResult;
    get: () => SuiteResult;
    reset: () => void;
    resetField: (fieldName: string) => void;
    remove: (fieldName: string) => void;
};
type IsolateCursor = {
    current: () => number;
    next: () => void;
};
declare enum IsolateTypes {
    DEFAULT = 0,
    SUITE = 1,
    EACH = 2,
    SKIP_WHEN = 3,
    OMIT_WHEN = 4,
    GROUP = 5
}
type IsolateKeys = {
    current: Record<string, VestTest>;
    prev: Record<string, VestTest>;
};
type Isolate = {
    type: IsolateTypes;
    keys: IsolateKeys;
    path: number[];
    cursor: IsolateCursor;
};
declare enum Modes {
    ALL = 0,
    EAGER = 1
}
/**
 * Marks a field as optional, either just by name, or by a given condition.
 *
 * @example
 *
 * optional('field_name');
 *
 * optional({
 *  username: () => allowUsernameEmpty,
 * });
 */
declare function optional(optionals: OptionalsInput): void;
type OptionalsInput = string | string[] | OptionalsObject;
type OptionalsObject = Record<string, (() => boolean) | boolean>;
type ImmediateOptionalFieldDeclaration = {
    type: OptionalFieldTypes.Immediate;
    rule: boolean | (() => boolean);
    applied: boolean;
};
type DelayedOptionalFieldDeclaration = {
    type: OptionalFieldTypes.Delayed;
    applied: boolean;
    rule: null;
};
type OptionalFieldDeclaration = ImmediateOptionalFieldDeclaration | DelayedOptionalFieldDeclaration;
declare enum OptionalFieldTypes {
    Immediate = 0,
    Delayed = 1
}
type StateRef = {
    optionalFields: UseState<OptionalFields>;
    suiteId: UseState<string>;
    suiteName: UseState<SuiteName>;
    testCallbacks: UseState<TestCallbacks>;
    testObjects: UseState<TestObjects>;
};
type OptionalFields = Record<string, OptionalFieldDeclaration>;
type TestCallbacks = {
    fieldCallbacks: Record<string, Array<(res: SuiteResult) => void>>;
    doneCallbacks: Array<(res: SuiteResult) => void>;
};
type TestObjects = {
    prev: VestTests;
    current: VestTests;
};
type VestTests = nestedArray.NestedArray<VestTest>;
declare const _default: import("context").CtxCascadeApi<CTXType>;
type CTXType = {
    isolate: Isolate;
    stateRef?: StateRef;
    exclusion: {
        tests: Record<string, boolean>;
        groups: Record<string, boolean>;
    };
    inclusion: Record<string, boolean | (() => boolean)>;
    currentTest?: VestTest;
    groupName?: string;
    skipped?: boolean;
    omitted?: boolean;
    mode: [
        Modes
    ];
    bus?: {
        on: (event: string, handler: CB) => {
            off: () => void;
        };
        emit: (event: string, ...args: any[]) => void;
    };
};
declare const context: typeof _default;
/**
 * Iterates over an array of items, allowing to run tests individually per item.
 *
 * Requires setting a "key" property on each item tested.
 *
 * @example
 *
 * each(itemsArray, (item) => {
 *  test(item.name, 'Item value must not be empty', () => {
 *    enforce(item.value).isNotEmpty();
 *  }, item.id)
 * })
 */
declare function each<T>(list: T[], callback: (arg: T, index: number) => void): void;
type ExclusionItem = string | string[] | undefined;
/**
 * Adds a field or a list of fields into the inclusion list
 *
 * @example
 *
 * only('username');
 */
declare function only(item: ExclusionItem): void;
declare namespace only {
    var group: (item: ExclusionItem) => void;
}
/**
 * Adds a field or a list of fields into the exclusion list
 *
 * @example
 *
 * skip('username');
 */
declare function skip(item: ExclusionItem): void;
declare namespace skip {
    var group: (item: ExclusionItem) => void;
}
/**
 * Runs tests within a group so that they can be controlled or queried separately.
 *
 * @example
 *
 * group('group_name', () => {
 *  // Tests go here
 * });
 */
declare function group(groupName: string, tests: () => void): void;
declare function include(fieldName: string): {
    when: (condition: string | boolean | ((draft: SuiteResult) => boolean)) => void;
};
/**
 * Sets the suite to "eager" (fail fast) mode.
 * Eager mode will skip running subsequent tests of a failing fields.
 *
 * @example
 *  // in the following example, the second test of username will not run
 *  // if the first test of username failed.
 * const suite = create((data) => {
 *  eager();
 *
 *  test('username', 'username is required', () => {
 *   enforce(data.username).isNotBlank();
 *  });
 *
 *  test('username', 'username is too short', () => {
 *   enforce(data.username).longerThan(2);
 *  });
 * });
 */
declare function eager(): void;
/**
 * Conditionally omits tests from the suite.
 *
 * @example
 *
 * omitWhen(res => res.hasErrors('username'), () => {
 *  test('username', 'User already taken', async () => await doesUserExist(username)
 * });
 */
declare function omitWhen(conditional: boolean | ((draft: SuiteResult) => boolean), callback: CB): void;
/**
 * Conditionally skips running tests within the callback.
 *
 * @example
 *
 * skipWhen(res => res.hasErrors('username'), () => {
 *  test('username', 'User already taken', async () => await doesUserExist(username)
 * });
 */
declare function skipWhen(conditional: boolean | ((draft: SuiteResult) => boolean), callback: CB): void;
declare function testBase(fieldName: string, message: string, cb: TestFn): VestTest;
declare function testBase(fieldName: string, cb: TestFn): VestTest;
declare function testBase(fieldName: string, message: string, cb: TestFn, key: string): VestTest;
declare function testBase(fieldName: string, cb: TestFn, key: string): VestTest;
/**
 * Represents a single case in a validation suite.
 *
 * @example
 *
 * test("username", "Username is required", () => {
 *  enforce(data.username).isNotBlank();
 * });
 */
declare const test: typeof testBase & {
    memo: {
        (fieldName: string, test: TestFn, dependencies: unknown[]): VestTest;
        (fieldName: string, message: string, test: TestFn, dependencies: unknown[]): VestTest;
    };
};
/**
 * Sets a running test to warn only mode.
 */
declare function warn(): void;
declare const VERSION = "4.6.11";
export { suiteSelectors, test, create, each, only, skip, warn, group, optional, skipWhen, omitWhen, enforce, VERSION, context, include, eager };
export type { SuiteResult, SuiteRunResult, SuiteSummary, VestTest, Suite };
//# sourceMappingURL=vest.d.ts.map