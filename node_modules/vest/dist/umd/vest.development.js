(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('n4s'), require('vast'), require('vest-utils'), require('context')) :
  typeof define === 'function' && define.amd ? define(['exports', 'n4s', 'vast', 'vest-utils', 'context'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vest = {}, global.n4s, global.vast, global["vest-utils"], global.context));
})(this, (function (exports, n4s, vast, vestUtils, context$1) { 'use strict';

  var IsolateTypes;
  (function (IsolateTypes) {
      IsolateTypes[IsolateTypes["DEFAULT"] = 0] = "DEFAULT";
      IsolateTypes[IsolateTypes["SUITE"] = 1] = "SUITE";
      IsolateTypes[IsolateTypes["EACH"] = 2] = "EACH";
      IsolateTypes[IsolateTypes["SKIP_WHEN"] = 3] = "SKIP_WHEN";
      IsolateTypes[IsolateTypes["OMIT_WHEN"] = 4] = "OMIT_WHEN";
      IsolateTypes[IsolateTypes["GROUP"] = 5] = "GROUP";
  })(IsolateTypes || (IsolateTypes = {}));

  function createStateRef(state, _a) {
      var suiteId = _a.suiteId, suiteName = _a.suiteName;
      return {
          optionalFields: state.registerStateKey(function () { return ({}); }),
          suiteId: state.registerStateKey(suiteId),
          suiteName: state.registerStateKey(suiteName),
          testCallbacks: state.registerStateKey(function () { return ({
              fieldCallbacks: {},
              doneCallbacks: []
          }); }),
          testObjects: state.registerStateKey(function (prev) {
              return {
                  prev: prev ? prev.current : [],
                  current: []
              };
          })
      };
  }

  var Modes;
  (function (Modes) {
      Modes[Modes["ALL"] = 0] = "ALL";
      Modes[Modes["EAGER"] = 1] = "EAGER";
  })(Modes || (Modes = {}));

  function createIsolateCursor() {
      var cursor = {
          value: 0
      };
      return {
          current: current,
          next: next
      };
      /**
       * @returns {number} The current value of the cursor
       */
      function current() {
          return cursor.value;
      }
      /**
       * Moves the isolate cursor forward by 1
       */
      function next() {
          cursor.value++;
      }
  }

  function generateIsolate(type, path) {
      if (path === void 0) { path = []; }
      return {
          cursor: createIsolateCursor(),
          keys: {
              current: {},
              prev: {}
          },
          path: path,
          type: type
      };
  }

  var context = context$1.createCascade(function (ctxRef, parentContext) {
      return parentContext
          ? null
          : vestUtils.assign({
              exclusion: {
                  tests: {},
                  groups: {}
              },
              inclusion: {},
              isolate: generateIsolate(IsolateTypes.DEFAULT),
              mode: [Modes.ALL]
          }, ctxRef);
  });

  /**
   * @returns {Isolate} The current isolate layer
   */
  function useIsolate() {
      return context.useX().isolate;
  }
  /**
   * @returns {number[]} The current cursor path of the isolate tree
   */
  function useCurrentPath() {
      var isolate = useIsolate();
      return isolate.path.concat(isolate.cursor.current());
  }
  /**
   * @returns {IsolateCursor} The cursor object for the current isolate
   */
  function useCursor() {
      return useIsolate().cursor;
  }

  function shouldUseErrorAsMessage(message, error) {
      // kind of cheating with this safe guard, but it does the job
      return vestUtils.isUndefined(message) && vestUtils.isStringValue(error);
  }

  // STATE REF
  function useStateRef() {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return context.useX().stateRef; // I should revisit this
  }
  // STATE KEYS
  function useSuiteId() {
      return useStateRef().suiteId()[0];
  }
  function useSuiteName() {
      return useStateRef().suiteName()[0];
  }
  function useTestCallbacks() {
      return useStateRef().testCallbacks();
  }
  // OPTIONAL FIELDS
  function useOptionalFields() {
      return useStateRef().optionalFields();
  }
  function useSetOptionalField(fieldName, setter) {
      var _a = useOptionalFields(), setOptionalFields = _a[1];
      setOptionalFields(function (prev) {
          var _a;
          return vestUtils.assign(prev, (_a = {},
              _a[fieldName] = vestUtils.assign({}, prev[fieldName], setter(prev[fieldName])),
              _a));
      });
  }
  function useOptionalField(fieldName) {
      var _a;
      var optionalFields = useOptionalFields()[0];
      return (_a = optionalFields[fieldName]) !== null && _a !== void 0 ? _a : {};
  }
  function useTestObjects() {
      return useStateRef().testObjects();
  }
  // STATE ACTIONS
  function useRefreshTestObjects() {
      useSetTests(function (tests) { return tests; });
  }
  function useSetTests(handler) {
      var _a = useTestObjects(), testObjects = _a[1];
      testObjects(function (_a) {
          var current = _a.current, prev = _a.prev;
          return ({
              prev: prev,
              current: vestUtils.asArray(handler(current))
          });
      });
  }
  // Derived state
  function useAllIncomplete() {
      return useTestsFlat().filter(function (test) { return test.isPending(); });
  }
  var flatCache = vestUtils.cache();
  function useTestsFlat() {
      var current = useTestObjects()[0].current;
      return flatCache([current], function () { return vestUtils.nestedArray.flatten(current); });
  }
  function useEachTestObject(handler) {
      var testObjects = useTestsFlat();
      testObjects.forEach(handler);
  }

  var TestSeverity;
  (function (TestSeverity) {
      TestSeverity["Error"] = "error";
      TestSeverity["Warning"] = "warning";
  })(TestSeverity || (TestSeverity = {}));
  var VestTest = /** @class */ (function () {
      function VestTest(fieldName, testFn, _a) {
          var _b = _a === void 0 ? {} : _a, message = _b.message, groupName = _b.groupName, key = _b.key;
          this.key = null;
          this.id = vestUtils.seq();
          this.severity = TestSeverity.Error;
          this.status = STATUS_UNTESTED;
          this.fieldName = fieldName;
          this.testFn = testFn;
          if (groupName) {
              this.groupName = groupName;
          }
          if (message) {
              this.message = message;
          }
          if (key) {
              this.key = key;
          }
      }
      VestTest.prototype.run = function () {
          var result;
          try {
              result = this.testFn();
          }
          catch (error) {
              if (shouldUseErrorAsMessage(this.message, error)) {
                  this.message = error;
              }
              result = false;
          }
          if (result === false) {
              this.fail();
          }
          return result;
      };
      VestTest.prototype.setStatus = function (status) {
          if (this.isFinalStatus() && status !== STATUS_OMITTED) {
              return;
          }
          this.status = status;
      };
      VestTest.prototype.warns = function () {
          return this.severity === TestSeverity.Warning;
      };
      VestTest.prototype.setPending = function () {
          this.setStatus(STATUS_PENDING);
      };
      VestTest.prototype.fail = function () {
          this.setStatus(this.warns() ? STATUS_WARNING : STATUS_FAILED);
      };
      VestTest.prototype.done = function () {
          if (this.isFinalStatus()) {
              return;
          }
          this.setStatus(STATUS_PASSING);
      };
      VestTest.prototype.warn = function () {
          this.severity = TestSeverity.Warning;
      };
      VestTest.prototype.isFinalStatus = function () {
          return this.hasFailures() || this.isCanceled() || this.isPassing();
      };
      VestTest.prototype.skip = function (force) {
          if (this.isPending() && !force) {
              // Without this condition, the test will be marked as skipped even if it is pending.
              // This means that it will not be counted in "allIncomplete" and its done callbacks
              // will not be called, or will be called prematurely.
              // What this mostly say is that when we have a pending test for one field, and we then
              // start typing in a different field - the pending test will be canceled, which
              // is usually an unwanted behavior.
              // The only scenario in which we DO want to cancel the async test regardless
              // is when we specifically skip a test with `skipWhen`, which is handled by the
              // "force" boolean flag.
              // I am not a fan of this flag, but it gets the job done.
              return;
          }
          this.setStatus(STATUS_SKIPPED);
      };
      VestTest.prototype.cancel = function () {
          this.setStatus(STATUS_CANCELED);
          useRefreshTestObjects();
      };
      VestTest.prototype.reset = function () {
          this.status = STATUS_UNTESTED;
          useRefreshTestObjects();
      };
      VestTest.prototype.omit = function () {
          this.setStatus(STATUS_OMITTED);
      };
      VestTest.prototype.valueOf = function () {
          return !this.isFailing();
      };
      VestTest.prototype.isPending = function () {
          return this.statusEquals(STATUS_PENDING);
      };
      VestTest.prototype.isOmitted = function () {
          return this.statusEquals(STATUS_OMITTED);
      };
      VestTest.prototype.isUntested = function () {
          return this.statusEquals(STATUS_UNTESTED);
      };
      VestTest.prototype.isFailing = function () {
          return this.statusEquals(STATUS_FAILED);
      };
      VestTest.prototype.isCanceled = function () {
          return this.statusEquals(STATUS_CANCELED);
      };
      VestTest.prototype.isSkipped = function () {
          return this.statusEquals(STATUS_SKIPPED);
      };
      VestTest.prototype.isPassing = function () {
          return this.statusEquals(STATUS_PASSING);
      };
      VestTest.prototype.isWarning = function () {
          return this.statusEquals(STATUS_WARNING);
      };
      VestTest.prototype.hasFailures = function () {
          return this.isFailing() || this.isWarning();
      };
      VestTest.prototype.isNonActionable = function () {
          return this.isSkipped() || this.isOmitted() || this.isCanceled();
      };
      VestTest.prototype.isTested = function () {
          return this.hasFailures() || this.isPassing();
      };
      VestTest.prototype.awaitsResolution = function () {
          // Is the test in a state where it can still be run, or complete running
          // and its final status is indeterminate?
          return this.isSkipped() || this.isUntested() || this.isPending();
      };
      VestTest.prototype.statusEquals = function (status) {
          return this.status === status;
      };
      return VestTest;
  }());
  var STATUS_UNTESTED = 'UNTESTED';
  var STATUS_SKIPPED = 'SKIPPED';
  var STATUS_FAILED = 'FAILED';
  var STATUS_WARNING = 'WARNING';
  var STATUS_PASSING = 'PASSING';
  var STATUS_PENDING = 'PENDING';
  var STATUS_CANCELED = 'CANCELED';
  var STATUS_OMITTED = 'OMITTED';

  function usePrevKeys() {
      var prev = useTestObjects()[0].prev;
      return vestUtils.asArray(vestUtils.nestedArray.getCurrent(prev, useCurrentPath())).reduce(function (prevKeys, testObject) {
          if (!(testObject instanceof VestTest)) {
              return prevKeys;
          }
          if (vestUtils.isNullish(testObject.key)) {
              return prevKeys;
          }
          prevKeys[testObject.key] = testObject;
          return prevKeys;
      }, {});
  }
  function usePrevTestByKey(key) {
      var prev = useIsolate().keys.prev;
      return prev[key];
  }
  function useRetainTestKey(key, testObject) {
      var current = useIsolate().keys.current;
      if (vestUtils.isNullish(current[key])) {
          current[key] = testObject;
      }
      else {
          vestUtils.deferThrow("Encountered the same test key \"".concat(key, "\" twice. This may lead to tests overriding each other's results, or to tests being unexpectedly omitted."));
      }
  }

  function isolate(_a, callback) {
      var _b = _a.type, type = _b === void 0 ? IsolateTypes.DEFAULT : _b;
      vestUtils.invariant(vestUtils.isFunction(callback));
      // Generate a new Isolate layer, with its own cursor
      var isolate = generateIsolate(type, useCurrentPath());
      var output = context.run({ isolate: isolate }, function () {
          isolate.keys.prev = usePrevKeys();
          useSetTests(function (tests) { return vestUtils.nestedArray.setValueAtPath(tests, isolate.path, []); });
          var res = callback();
          return res;
      });
      // Move the parent cursor forward once we're done
      useCursor().next();
      return output;
  }
  /**
   * @returns {boolean} Whether or not the current isolate allows tests to be reordered
   */
  function shouldAllowReorder() {
      return useIsolate().type === IsolateTypes.EACH;
  }

  var Severity;
  (function (Severity) {
      Severity["WARNINGS"] = "warnings";
      Severity["ERRORS"] = "errors";
  })(Severity || (Severity = {}));
  var SeverityCount;
  (function (SeverityCount) {
      SeverityCount["ERROR_COUNT"] = "errorCount";
      SeverityCount["WARN_COUNT"] = "warnCount";
  })(SeverityCount || (SeverityCount = {}));
  function countKeyBySeverity(severity) {
      return severity === Severity.ERRORS
          ? SeverityCount.ERROR_COUNT
          : SeverityCount.WARN_COUNT;
  }

  function nonMatchingFieldName(testObject, fieldName) {
      return !!fieldName && !matchingFieldName(testObject, fieldName);
  }
  function matchingFieldName(testObject, fieldName) {
      return !!(fieldName && testObject.fieldName === fieldName);
  }

  var nonMatchingGroupName = vestUtils.bindNot(matchingGroupName);
  function matchingGroupName(testObject, groupName) {
      return testObject.groupName === groupName;
  }

  /**
   * Checks that a given test object matches the currently specified severity level
   */
  function nonMatchingSeverityProfile(severity, testObject) {
      return vestUtils.either(severity === Severity.WARNINGS, testObject.warns());
  }

  /**
   * The difference between this file and hasFailures is that hasFailures uses the static
   * summary object, while this one uses the actual validation state
   */
  function hasErrorsByTestObjects(fieldName) {
      return hasFailuresByTestObjects(Severity.ERRORS, fieldName);
  }
  function hasFailuresByTestObjects(severityKey, fieldName) {
      var testObjects = useTestsFlat();
      return testObjects.some(function (testObject) {
          return hasFailuresByTestObject(testObject, severityKey, fieldName);
      });
  }
  function hasGroupFailuresByTestObjects(severityKey, groupName, fieldName) {
      var testObjects = useTestsFlat();
      return testObjects.some(function (testObject) {
          if (nonMatchingGroupName(testObject, groupName)) {
              return false;
          }
          return hasFailuresByTestObject(testObject, severityKey, fieldName);
      });
  }
  /**
   * Determines whether a certain test profile has failures.
   */
  function hasFailuresByTestObject(testObject, severityKey, fieldName) {
      if (!testObject.hasFailures()) {
          return false;
      }
      if (nonMatchingFieldName(testObject, fieldName)) {
          return false;
      }
      if (nonMatchingSeverityProfile(severityKey, testObject)) {
          return false;
      }
      return true;
  }

  /**
   * Marks a field as optional, either just by name, or by a given condition.
   *
   * @example
   *
   * optional('field_name');
   *
   * optional({
   *  username: () => allowUsernameEmpty,
   * });
   */
  function optional(optionals) {
      // There are two types of optional field declarations:
      // 1. Delayed: A string, which is the name of the field to be optional.
      // We will only determine whether to omit the test after the suite is done running
      //
      // 2. Immediate: Either a boolean or a function, which is used to determine
      // if the field should be optional.
      // Delayed case (field name)
      if (vestUtils.isArray(optionals) || vestUtils.isStringValue(optionals)) {
          vestUtils.asArray(optionals).forEach(function (optionalField) {
              useSetOptionalField(optionalField, function () { return ({
                  type: OptionalFieldTypes.Delayed,
                  applied: false,
                  rule: null
              }); });
          });
      }
      else {
          var _loop_1 = function (field) {
              var value = optionals[field];
              useSetOptionalField(field, function () { return ({
                  type: OptionalFieldTypes.Immediate,
                  rule: value,
                  applied: vestUtils.optionalFunctionValue(value)
              }); });
          };
          // Immediately case (function or boolean)
          for (var field in optionals) {
              _loop_1(field);
          }
      }
  }
  function optionalFiedIsApplied(fieldName) {
      if (!fieldName) {
          return false;
      }
      return useOptionalField(fieldName).applied;
  }
  var OptionalFieldTypes;
  (function (OptionalFieldTypes) {
      OptionalFieldTypes[OptionalFieldTypes["Immediate"] = 0] = "Immediate";
      OptionalFieldTypes[OptionalFieldTypes["Delayed"] = 1] = "Delayed";
  })(OptionalFieldTypes || (OptionalFieldTypes = {}));

  // eslint-disable-next-line max-statements, complexity
  function shouldAddValidProperty(fieldName) {
      // Is the field optional, and the optional condition is applied
      if (optionalFiedIsApplied(fieldName)) {
          return true;
      }
      var testObjects = useTestsFlat();
      // Are there no tests?
      if (vestUtils.isEmpty(testObjects)) {
          return false;
      }
      // Does the field have any tests with errors?
      if (hasErrorsByTestObjects(fieldName)) {
          return false;
      }
      // Does the given field have any pending tests that are not optional?
      if (hasNonOptionalIncomplete(fieldName)) {
          return false;
      }
      // Does the field have no missing tests?
      return noMissingTests(fieldName);
  }
  function shouldAddValidPropertyInGroup(groupName, fieldName) {
      if (optionalFiedIsApplied(fieldName)) {
          return true;
      }
      if (hasGroupFailuresByTestObjects(Severity.ERRORS, groupName, fieldName)) {
          return false;
      }
      // Do the given group/field have any pending tests that are not optional?
      if (hasNonOptionalIncompleteByGroup(groupName, fieldName)) {
          return false;
      }
      return noMissingTestsByGroup(groupName, fieldName);
  }
  // Does the given field have any pending tests that are not optional?
  function hasNonOptionalIncomplete(fieldName) {
      return useAllIncomplete().some(function (testObject) {
          return isTestObjectOptional(testObject, fieldName);
      });
  }
  // Do the given group/field have any pending tests that are not optional?
  function hasNonOptionalIncompleteByGroup(groupName, fieldName) {
      return useAllIncomplete().some(function (testObject) {
          if (nonMatchingGroupName(testObject, groupName)) {
              return false;
          }
          return isTestObjectOptional(testObject, fieldName);
      });
  }
  function isTestObjectOptional(testObject, fieldName) {
      if (nonMatchingFieldName(testObject, fieldName)) {
          return false;
      }
      return optionalFiedIsApplied(fieldName);
  }
  // Did all of the tests for the provided field run/omit?
  // This makes sure that the fields are not skipped or pending.
  function noMissingTests(fieldName) {
      var testObjects = useTestsFlat();
      return testObjects.every(function (testObject) {
          return noMissingTestsLogic(testObject, fieldName);
      });
  }
  // Does the group have no missing tests?
  function noMissingTestsByGroup(groupName, fieldName) {
      var testObjects = useTestsFlat();
      return testObjects.every(function (testObject) {
          if (nonMatchingGroupName(testObject, groupName)) {
              return true;
          }
          return noMissingTestsLogic(testObject, fieldName);
      });
  }
  // Does the object qualify as either tested or omitted (but not skipped!)
  function noMissingTestsLogic(testObject, fieldName) {
      if (nonMatchingFieldName(testObject, fieldName)) {
          return true;
      }
      /**
       * The reason we're checking for the optional field here and not in "omitOptionalFields"
       * is because that unlike the bool/function check we do there, here it only depends on
       * whether the field was tested alredy or not.
       *
       * We qualify the test as not missing only if it was already run, if it is omitted,
       * or if it is marked as optional, even if the optional check did not apply yet -
       * but the test did not reach its final state.
       */
      return (optionalTestAwaitsResolution(testObject) ||
          testObject.isTested() ||
          testObject.isOmitted());
  }
  function optionalTestAwaitsResolution(testObject) {
      // Does the test belong to an optional field,
      // and the test itself is still in an indeterminate state?
      return (useOptionalField(testObject.fieldName).type ===
          OptionalFieldTypes.Delayed && testObject.awaitsResolution());
  }

  /**
   * Reads the testObjects list and gets full validation result from it.
   */
  function genTestsSummary() {
      var testObjects = useTestsFlat();
      var summary = vestUtils.assign(baseStats(), {
          groups: {},
          tests: {},
          valid: false
      });
      testObjects.reduce(function (summary, testObject) {
          appendToTest(summary.tests, testObject);
          appendToGroup(summary.groups, testObject);
          return summary;
      }, summary);
      summary.valid = shouldAddValidProperty();
      return countFailures(summary);
  }
  function appendToTest(tests, testObject) {
      tests[testObject.fieldName] = appendTestObject(tests, testObject);
      // If `valid` is false to begin with, keep it that way. Otherwise, assess.
      tests[testObject.fieldName].valid =
          tests[testObject.fieldName].valid === false
              ? false
              : shouldAddValidProperty(testObject.fieldName);
  }
  /**
   * Appends to a group object if within a group
   */
  function appendToGroup(groups, testObject) {
      var groupName = testObject.groupName;
      if (!groupName) {
          return;
      }
      groups[groupName] = groups[groupName] || {};
      groups[groupName][testObject.fieldName] = appendTestObject(groups[groupName], testObject);
      groups[groupName][testObject.fieldName].valid =
          groups[groupName][testObject.fieldName].valid === false
              ? false
              : shouldAddValidPropertyInGroup(groupName, testObject.fieldName);
  }
  /**
   * Counts the failed tests and adds global counters
   */
  function countFailures(summary) {
      for (var test in summary.tests) {
          summary.errorCount += summary.tests[test].errorCount;
          summary.warnCount += summary.tests[test].warnCount;
          summary.testCount += summary.tests[test].testCount;
      }
      return summary;
  }
  function appendTestObject(summaryKey, testObject) {
      var fieldName = testObject.fieldName, message = testObject.message;
      summaryKey[fieldName] = summaryKey[fieldName] || baseTestStats();
      var testKey = summaryKey[fieldName];
      if (testObject.isNonActionable())
          return testKey;
      summaryKey[fieldName].testCount++;
      if (testObject.isFailing()) {
          incrementFailures(Severity.ERRORS);
      }
      else if (testObject.isWarning()) {
          incrementFailures(Severity.WARNINGS);
      }
      return testKey;
      function incrementFailures(severity) {
          var countKey = countKeyBySeverity(severity);
          testKey[countKey]++;
          if (message) {
              testKey[severity] = (testKey[severity] || []).concat(message);
          }
      }
  }
  function baseStats() {
      return {
          errorCount: 0,
          warnCount: 0,
          testCount: 0
      };
  }
  function baseTestStats() {
      return vestUtils.assign(baseStats(), {
          errors: [],
          warnings: []
      });
  }

  // calls collectAll or getByFieldName depending on whether fieldName is provided
  function gatherFailures(testGroup, severityKey, fieldName) {
      return fieldName
          ? getByFieldName(testGroup, severityKey, fieldName)
          : collectAll(testGroup, severityKey);
  }
  function getByFieldName(testGroup, severityKey, fieldName) {
      var _a;
      return ((_a = testGroup === null || testGroup === void 0 ? void 0 : testGroup[fieldName]) === null || _a === void 0 ? void 0 : _a[severityKey]) || [];
  }
  function collectAll(testGroup, severityKey) {
      var output = {};
      var countKey = countKeyBySeverity(severityKey);
      for (var field in testGroup) {
          if (vestUtils.isPositive(testGroup[field][countKey])) {
              // We will probably never get to the fallback array
              // leaving it just in case the implementation changes
              output[field] = testGroup[field][severityKey] || [];
          }
      }
      return output;
  }

  // eslint-disable-next-line max-lines-per-function, max-statements
  function suiteSelectors(summary) {
      var selectors = {
          getErrors: getErrors,
          getErrorsByGroup: getErrorsByGroup,
          getWarnings: getWarnings,
          getWarningsByGroup: getWarningsByGroup,
          hasErrors: hasErrors,
          hasErrorsByGroup: hasErrorsByGroup,
          hasWarnings: hasWarnings,
          hasWarningsByGroup: hasWarningsByGroup,
          isValid: isValid,
          isValidByGroup: isValidByGroup
      };
      return selectors;
      // Booleans
      function isValid(fieldName) {
          var _a;
          return fieldName ? Boolean((_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.valid) : summary.valid;
      }
      function isValidByGroup(groupName, fieldName) {
          var group = summary.groups[groupName];
          if (!group) {
              return false;
          }
          if (fieldName) {
              return isFieldValid(group, fieldName);
          }
          for (var fieldName_1 in group) {
              if (!isFieldValid(group, fieldName_1)) {
                  return false;
              }
          }
          return true;
      }
      function hasWarnings(fieldName) {
          return hasFailures(summary, SeverityCount.WARN_COUNT, fieldName);
      }
      function hasErrors(fieldName) {
          return hasFailures(summary, SeverityCount.ERROR_COUNT, fieldName);
      }
      function hasWarningsByGroup(groupName, fieldName) {
          return hasFailuresByGroup(summary, SeverityCount.WARN_COUNT, groupName, fieldName);
      }
      function hasErrorsByGroup(groupName, fieldName) {
          return hasFailuresByGroup(summary, SeverityCount.ERROR_COUNT, groupName, fieldName);
      }
      function getWarnings(fieldName) {
          return getFailures(summary, Severity.WARNINGS, fieldName);
      }
      function getErrors(fieldName) {
          return getFailures(summary, Severity.ERRORS, fieldName);
      }
      function getErrorsByGroup(groupName, fieldName) {
          return getFailuresByGroup(summary, Severity.ERRORS, groupName, fieldName);
      }
      function getWarningsByGroup(groupName, fieldName) {
          return getFailuresByGroup(summary, Severity.WARNINGS, groupName, fieldName);
      }
  }
  // Gathers all failures of a given severity
  // With a fieldName, it will only gather failures for that field
  function getFailures(summary, severityKey, fieldName) {
      return gatherFailures(summary.tests, severityKey, fieldName);
  }
  // Gathers all failures of a given severity within a group
  // With a fieldName, it will only gather failures for that field
  function getFailuresByGroup(summary, severityKey, groupName, fieldName) {
      return gatherFailures(summary.groups[groupName], severityKey, fieldName);
  }
  // Checks if a field is valid within a container object - can be within a group or top level
  function isFieldValid(testContainer, fieldName) {
      var _a;
      return !!((_a = testContainer[fieldName]) === null || _a === void 0 ? void 0 : _a.valid);
  }
  // Checks if a there are any failures of a given severity within a group
  // If a fieldName is provided, it will only check for failures within that field
  function hasFailuresByGroup(summary, severityCount, groupName, fieldName) {
      var _a, _b;
      var group = summary.groups[groupName];
      if (!group) {
          return false;
      }
      if (fieldName) {
          return vestUtils.isPositive((_a = group[fieldName]) === null || _a === void 0 ? void 0 : _a[severityCount]);
      }
      for (var field in group) {
          if (vestUtils.isPositive((_b = group[field]) === null || _b === void 0 ? void 0 : _b[severityCount])) {
              return true;
          }
      }
      return false;
  }
  // Checks if there are any failures of a given severity
  // If a fieldName is provided, it will only check for failures within that field
  function hasFailures(summary, countKey, fieldName) {
      var _a;
      var failureCount = fieldName
          ? (_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a[countKey]
          : summary[countKey] || 0;
      return vestUtils.isPositive(failureCount);
  }

  var cache$1 = vestUtils.cache(1);
  function produceSuiteResult() {
      var testObjects = useTestsFlat();
      var ctxRef = { stateRef: useStateRef() };
      return cache$1([testObjects], context.bind(ctxRef, function () {
          var summary = genTestsSummary();
          var suiteName = useSuiteName();
          return vestUtils.assign(summary, suiteSelectors(summary), {
              suiteName: suiteName
          });
      }));
  }

  /**
   * Checks if a given field, or the suite as a whole still have remaining tests.
   */
  function hasRemainingTests(fieldName) {
      var allIncomplete = useAllIncomplete();
      if (vestUtils.isEmpty(allIncomplete)) {
          return false;
      }
      if (fieldName) {
          return allIncomplete.some(function (testObject) {
              return matchingFieldName(testObject, fieldName);
          });
      }
      return true;
  }

  var cache = vestUtils.cache(20);
  function produceFullResult() {
      var testObjects = useTestsFlat();
      var ctxRef = { stateRef: useStateRef() };
      return cache([testObjects], context.bind(ctxRef, function () {
          return vestUtils.assign({}, produceSuiteResult(), {
              done: context.bind(ctxRef, done)
          });
      }));
  }
  /**
   * DONE is here and not in its own module to prevent circular dependency issues.
   */
  function shouldSkipDoneRegistration(callback, fieldName, output) {
      var _a;
      // If we do not have any test runs for the current field
      return !!(!vestUtils.isFunction(callback) ||
          (fieldName && vestUtils.numberEquals((_a = output.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.testCount, 0)));
  }
  function shouldRunDoneCallback(fieldName) {
      // is suite finished || field name exists, and test is finished;
      return !!(!hasRemainingTests() ||
          (fieldName && !hasRemainingTests(fieldName)));
  }
  /**
   * Registers done callbacks.
   * @register {Object} Vest output object.
   */
  var done = function done() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var _a = args.reverse(), callback = _a[0], fieldName = _a[1];
      var output = produceFullResult();
      if (shouldSkipDoneRegistration(callback, fieldName, output)) {
          return output;
      }
      var doneCallback = function () { return callback(produceSuiteResult()); };
      if (shouldRunDoneCallback(fieldName)) {
          doneCallback();
          return output;
      }
      deferDoneCallback(doneCallback, fieldName);
      return output;
  };
  function deferDoneCallback(doneCallback, fieldName) {
      var _a = useTestCallbacks(), setTestCallbacks = _a[1];
      setTestCallbacks(function (current) {
          if (fieldName) {
              current.fieldCallbacks[fieldName] = (current.fieldCallbacks[fieldName] || []).concat(doneCallback);
          }
          else {
              current.doneCallbacks.push(doneCallback);
          }
          return current;
      });
  }

  /**
   * This module gets triggered once the suite is done running its sync tests.
   *
   * It goes over all the tests in the state, and checks if they need to be omitted.
   */
  function omitOptionalFields() {
      var optionalFields = useOptionalFields()[0];
      // If there are no optional fields, we don't need to do anything
      if (vestUtils.isEmpty(optionalFields)) {
          return;
      }
      // Create an object to store the fields that need to be omitted
      var shouldOmit = {};
      // iterate over each of the tests in the state
      useTestsFlat().forEach(function (testObject) {
          // If we already added the current field (not this test specifically)
          // no need for further checks, go and omit the test
          if (vestUtils.hasOwnProperty(shouldOmit, testObject.fieldName)) {
              verifyAndOmit(testObject);
          }
          else {
              // check if the field has an optional function
              // if so, run it and verify/omit the test
              runOptionalConfig(testObject);
          }
      });
      // refresh the tests in the state so that the omitted fields are applied
      useRefreshTestObjects();
      function verifyAndOmit(testObject) {
          if (shouldOmit[testObject.fieldName]) {
              testObject.omit();
              useSetOptionalField(testObject.fieldName, function () { return ({
                  applied: true
              }); });
          }
      }
      function runOptionalConfig(testObject) {
          // Ge the optional configuration for the given field
          var optionalConfig = useOptionalField(testObject.fieldName);
          // If the optional was set to a function or a boolean, run it and verify/omit the test
          if (optionalConfig.type === OptionalFieldTypes.Immediate) {
              shouldOmit[testObject.fieldName] = vestUtils.optionalFunctionValue(optionalConfig.rule);
              verifyAndOmit(testObject);
          }
      }
  }

  /**
   * Removes test object from suite state
   */
  function removeTestFromState (testObject) {
      useSetTests(function (tests) {
          return vestUtils.nestedArray.transform(tests, function (test) { return (testObject !== test ? test : null); });
      });
  }

  /**
   * Runs done callback per field when async tests are finished running.
   */
  function runFieldCallbacks(fieldName) {
      var fieldCallbacks = useTestCallbacks()[0].fieldCallbacks;
      if (fieldName &&
          !hasRemainingTests(fieldName) &&
          vestUtils.isArray(fieldCallbacks[fieldName])) {
          vestUtils.callEach(fieldCallbacks[fieldName]);
      }
  }
  /**
   * Runs unlabelled done callback when async tests are finished running.
   */
  function runDoneCallbacks() {
      var doneCallbacks = useTestCallbacks()[0].doneCallbacks;
      vestUtils.callEach(doneCallbacks);
  }

  // eslint-disable-next-line max-lines-per-function
  function initBus() {
      var vestBus = vestUtils.bus.createBus();
      // Report a the completion of a test. There may be other tests with the same
      // name that are still running, or not yet started.
      vestBus.on(Events.TEST_COMPLETED, function (testObject) {
          if (testObject.isCanceled()) {
              return;
          }
          testObject.done();
          runFieldCallbacks(testObject.fieldName);
          if (!hasRemainingTests()) {
              // When no more tests are running, emit the done event
              vestBus.emit(Events.ALL_RUNNING_TESTS_FINISHED);
          }
      });
      // Report that the suite completed its synchronous test run.
      // Async operations may still be running.
      vestBus.on(Events.SUITE_CALLBACK_DONE_RUNNING, function () {
          // Remove tests that are optional and need to be omitted
          omitOptionalFields();
      });
      // Called when all the tests, including async, are done running
      vestBus.on(Events.ALL_RUNNING_TESTS_FINISHED, function () {
          runDoneCallbacks();
      });
      // Removes a certain field from the state.
      vestBus.on(Events.REMOVE_FIELD, function (fieldName) {
          useEachTestObject(function (testObject) {
              if (matchingFieldName(testObject, fieldName)) {
                  testObject.cancel();
                  removeTestFromState(testObject);
              }
          });
      });
      // Resets a certain field in the state.
      vestBus.on(Events.RESET_FIELD, function (fieldName) {
          useEachTestObject(function (testObject) {
              if (matchingFieldName(testObject, fieldName)) {
                  testObject.reset();
              }
          });
      });
      return vestBus;
  }
  function useBus() {
      var context$1 = context.useX();
      vestUtils.invariant(context$1.bus);
      return context$1.bus;
  }
  var Events;
  (function (Events) {
      Events["TEST_COMPLETED"] = "test_completed";
      Events["ALL_RUNNING_TESTS_FINISHED"] = "all_running_tests_finished";
      Events["REMOVE_FIELD"] = "remove_field";
      Events["RESET_FIELD"] = "reset_field";
      Events["SUITE_CALLBACK_DONE_RUNNING"] = "suite_callback_done_running";
  })(Events || (Events = {}));

  function create() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var _a = args.reverse(), suiteCallback = _a[0], suiteName = _a[1];
      vestUtils.invariant(vestUtils.isFunction(suiteCallback), 'vest.create: Expected callback to be a function.');
      // Event bus initialization
      var bus = initBus();
      // State initialization
      var state = vast.createState();
      // State reference - this holds the actual state values
      var stateRef = createStateRef(state, { suiteId: vestUtils.seq(), suiteName: suiteName });
      // Create base context reference. All hooks will derive their data from this
      var ctxRef = { stateRef: stateRef, bus: bus };
      var suite = vestUtils.assign(
      // Bind the suite body to the context
      context.bind(ctxRef, function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          // Reset the state. Migrates current test objects to `prev` array.
          state.reset();
          // Create a top level isolate
          isolate({ type: IsolateTypes.SUITE }, function () {
              // Run the consumer's callback
              suiteCallback.apply(void 0, args);
          });
          // Report the suite is done registering tests
          // Async tests may still be running
          bus.emit(Events.SUITE_CALLBACK_DONE_RUNNING);
          // Return the result
          return produceFullResult();
      }), {
          get: context.bind(ctxRef, produceSuiteResult),
          remove: context.bind(ctxRef, function (fieldName) {
              bus.emit(Events.REMOVE_FIELD, fieldName);
          }),
          reset: state.reset,
          resetField: context.bind(ctxRef, function (fieldName) {
              bus.emit(Events.RESET_FIELD, fieldName);
          })
      });
      return suite;
  }

  /**
   * Iterates over an array of items, allowing to run tests individually per item.
   *
   * Requires setting a "key" property on each item tested.
   *
   * @example
   *
   * each(itemsArray, (item) => {
   *  test(item.name, 'Item value must not be empty', () => {
   *    enforce(item.value).isNotEmpty();
   *  }, item.id)
   * })
   */
  function each(list, callback) {
      vestUtils.invariant(vestUtils.isFunction(callback), 'each callback must be a function');
      isolate({ type: IsolateTypes.EACH }, function () {
          list.forEach(function (arg, index) {
              callback(arg, index);
          });
      });
  }

  /**
   * Error message to display when a hook was called outside of context.
   */
  var ERROR_HOOK_CALLED_OUTSIDE = 'hook called outside of a running suite.';

  /**
   * Conditionally skips running tests within the callback.
   *
   * @example
   *
   * skipWhen(res => res.hasErrors('username'), () => {
   *  test('username', 'User already taken', async () => await doesUserExist(username)
   * });
   */
  function skipWhen(conditional, callback) {
      isolate({ type: IsolateTypes.SKIP_WHEN }, function () {
          context.run({
              skipped: 
              // Checking for nested conditional. If we're in a nested skipWhen,
              // we should skip the test if the parent conditional is true.
              isExcludedIndividually() ||
                  // Otherwise, we should skip the test if the conditional is true.
                  vestUtils.optionalFunctionValue(conditional, vestUtils.optionalFunctionValue(produceSuiteResult))
          }, function () { return callback(); });
      });
  }
  function isExcludedIndividually() {
      return !!context.useX().skipped;
  }

  /**
   * Adds a field or a list of fields into the inclusion list
   *
   * @example
   *
   * only('username');
   */
  function only(item) {
      return addTo(0 /* ExclusionGroup.ONLY */, 'tests', item);
  }
  only.group = function (item) {
      return addTo(0 /* ExclusionGroup.ONLY */, 'groups', item);
  };
  /**
   * Adds a field or a list of fields into the exclusion list
   *
   * @example
   *
   * skip('username');
   */
  function skip(item) {
      return addTo(1 /* ExclusionGroup.SKIP */, 'tests', item);
  }
  skip.group = function (item) {
      return addTo(1 /* ExclusionGroup.SKIP */, 'groups', item);
  };
  //Checks whether a certain test profile excluded by any of the exclusion groups.
  // eslint-disable-next-line complexity, max-statements
  function isExcluded(testObject) {
      var fieldName = testObject.fieldName, groupName = testObject.groupName;
      if (isExcludedIndividually())
          return true;
      var context$1 = context.useX();
      var exclusion = context$1.exclusion;
      var inclusion = context$1.inclusion;
      var keyTests = exclusion.tests;
      var testValue = keyTests[fieldName];
      // if test is skipped
      // no need to proceed
      if (testValue === false)
          return true;
      var isTestIncluded = testValue === true;
      // If inside a group
      if (groupName) {
          if (isGroupExcluded(groupName)) {
              return true; // field excluded by group
              // if group is `only`ed
          }
          else if (exclusion.groups[groupName] === true) {
              if (isTestIncluded)
                  return false;
              // If there is _ANY_ `only`ed test (and we already know this one isn't)
              if (hasIncludedTests(keyTests))
                  return true; // Excluded implicitly
              return keyTests[fieldName] === false;
          }
      }
      if (isTopLevelWhenThereIsAnIncludedGroup(groupName)) {
          return true;
      }
      // if field is only'ed
      if (isTestIncluded)
          return false;
      // If there is _ANY_ `only`ed test (and we already know this one isn't) return true
      if (hasIncludedTests(keyTests)) {
          // Check if inclusion rules for this field (`include` hook)
          // TODO: Check if this may need to be moved outside of the condition.
          // What if there are no included tests? This shouldn't run then?
          return !vestUtils.optionalFunctionValue(inclusion[fieldName]);
      }
      // We're done here. This field is not excluded
      return false;
  }
  /**
   * Checks whether a given group is excluded from running.
   */
  function isGroupExcluded(groupName) {
      var context$1 = context.useX();
      var exclusion = context$1.exclusion;
      var keyGroups = exclusion.groups;
      var groupPresent = vestUtils.hasOwnProperty(keyGroups, groupName);
      // When group is either only'ed or skipped
      if (groupPresent) {
          // Return true if group is skipped and false if only'ed
          return keyGroups[groupName] === false;
      }
      // Group is not present
      // Return whether other groups are included
      return hasIncludedGroups();
  }
  /**
   * Adds fields to a specified exclusion group.
   */
  function addTo(exclusionGroup, itemType, item) {
      var context$1 = context.useX(ERROR_HOOK_CALLED_OUTSIDE);
      if (!item) {
          return;
      }
      vestUtils.asArray(item).forEach(function (itemName) {
          if (!vestUtils.isStringValue(itemName)) {
              return;
          }
          context$1.exclusion[itemType][itemName] =
              exclusionGroup === 0 /* ExclusionGroup.ONLY */;
      });
  }
  /**
   * Checks if context has included tests
   */
  function hasIncludedTests(keyTests) {
      for (var test in keyTests) {
          if (keyTests[test] === true) {
              return true; // excluded implicitly
          }
      }
      return false;
  }
  // are we not in a group and there is an included group?
  function isTopLevelWhenThereIsAnIncludedGroup(groupName) {
      if (!hasIncludedGroups()) {
          return false;
      }
      // Return whether there's an included group, and we're not inside a group
      return !groupName;
  }
  function hasIncludedGroups() {
      var context$1 = context.useX();
      var exclusion = context$1.exclusion;
      for (var group in exclusion.groups) {
          if (exclusion.groups[group]) {
              return true;
          }
      }
      return false;
  }

  /**
   * Runs tests within a group so that they can be controlled or queried separately.
   *
   * @example
   *
   * group('group_name', () => {
   *  // Tests go here
   * });
   */
  function group(groupName, tests) {
      vestUtils.invariant(vestUtils.isStringValue(groupName), groupErrorMsg('name must be a string'));
      vestUtils.invariant(vestUtils.isFunction(tests), groupErrorMsg('callback must be a function'));
      // Running with the context applied
      isolate({ type: IsolateTypes.GROUP }, function () {
          context.run({ groupName: groupName }, tests);
      });
  }
  function groupErrorMsg(error) {
      return "Wrong arguments passed to group. Group ".concat(error, ".");
  }

  function include(fieldName) {
      var context$1 = context.useX();
      var inclusion = context$1.inclusion, exclusion = context$1.exclusion;
      vestUtils.invariant(vestUtils.isStringValue(fieldName));
      inclusion[fieldName] = vestUtils.defaultTo(exclusion.tests[fieldName], true);
      return { when: when };
      function when(condition) {
          var context$1 = context.useX();
          var inclusion = context$1.inclusion, exclusion = context$1.exclusion;
          // This callback will run as part of the "isExcluded" series of checks
          inclusion[fieldName] = function () {
              if (vestUtils.hasOwnProperty(exclusion.tests, fieldName)) {
                  // I suspect this code is technically unreachable because
                  // if there are any skip/only rules applied to the current
                  // field, the "isExcluded" function will have already bailed
                  return vestUtils.defaultTo(exclusion.tests[fieldName], true);
              }
              if (vestUtils.isStringValue(condition)) {
                  return Boolean(exclusion.tests[condition]);
              }
              return vestUtils.optionalFunctionValue(condition, vestUtils.optionalFunctionValue(produceSuiteResult));
          };
      }
  }

  /**
   * Sets the suite to "eager" (fail fast) mode.
   * Eager mode will skip running subsequent tests of a failing fields.
   *
   * @example
   *  // in the following example, the second test of username will not run
   *  // if the first test of username failed.
   * const suite = create((data) => {
   *  eager();
   *
   *  test('username', 'username is required', () => {
   *   enforce(data.username).isNotBlank();
   *  });
   *
   *  test('username', 'username is too short', () => {
   *   enforce(data.username).longerThan(2);
   *  });
   * });
   */
  function eager() {
      setMode(Modes.EAGER);
  }
  function shouldSkipBasedOnMode(testObject) {
      return isEager() && hasErrorsByTestObjects(testObject.fieldName);
  }
  function isEager() {
      return isMode(Modes.EAGER);
  }
  function isMode(mode) {
      var currentMode = context.useX().mode;
      return currentMode[0] === mode;
  }
  function setMode(nextMode) {
      var mode = context.useX().mode;
      mode[0] = nextMode;
  }

  /**
   * Conditionally omits tests from the suite.
   *
   * @example
   *
   * omitWhen(res => res.hasErrors('username'), () => {
   *  test('username', 'User already taken', async () => await doesUserExist(username)
   * });
   */
  function omitWhen(conditional, callback) {
      isolate({ type: IsolateTypes.OMIT_WHEN }, function () {
          context.run({
              omitted: inActiveOmitWhen() ||
                  vestUtils.optionalFunctionValue(conditional, vestUtils.optionalFunctionValue(produceSuiteResult))
          }, function () { return callback(); });
      });
  }
  // Checks that we're currently in an active omitWhen block
  function inActiveOmitWhen() {
      return !!context.useX().omitted;
  }

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  function isSameProfileTest(testObject1, testObject2) {
      return (testObject1.fieldName === testObject2.fieldName &&
          testObject1.groupName === testObject2.groupName);
  }

  function cancelOverriddenPendingTest(prevRunTestObject, currentRunTestObject) {
      if (currentRunTestObject !== prevRunTestObject &&
          isSameProfileTest(prevRunTestObject, currentRunTestObject) &&
          prevRunTestObject.isPending()) {
          prevRunTestObject.cancel();
      }
  }

  /**
   * Runs async test.
   */
  function runAsyncTest(testObject) {
      var asyncTest = testObject.asyncTest, message = testObject.message;
      if (!vestUtils.isPromise(asyncTest))
          return;
      var emit = useBus().emit;
      var stateRef = useStateRef();
      var done = context.bind({ stateRef: stateRef }, function () {
          // invalidating the "produce" cache
          useRefreshTestObjects();
          emit(Events.TEST_COMPLETED, testObject);
      });
      var fail = context.bind({ stateRef: stateRef }, function (rejectionMessage) {
          if (testObject.isCanceled()) {
              return;
          }
          testObject.message = vestUtils.isStringValue(rejectionMessage)
              ? rejectionMessage
              : message;
          testObject.fail();
          done();
      });
      asyncTest.then(done, fail);
  }

  /**
   * Runs sync tests - or extracts promise.
   */
  function runSyncTest(testObject) {
      return context.run({ currentTest: testObject }, function () { return testObject.run(); });
  }

  /**
   * Registers test, if async - adds to pending array
   */
  function registerTest(testObject) {
      var bus = useBus();
      // Run test callback.
      // If a promise is returned, set as async and
      // Move to pending list.
      var result = runSyncTest(testObject);
      try {
          // try catch for safe property access
          // in case object is an enforce chain
          if (vestUtils.isPromise(result)) {
              testObject.asyncTest = result;
              testObject.setPending();
              runAsyncTest(testObject);
          }
          else {
              bus.emit(Events.TEST_COMPLETED, testObject);
          }
      }
      catch (e) {
          throw new Error("Unexpected error encountered during test registration.\n      Test Object: ".concat(JSON.stringify(testObject), ".\n      Error: ").concat(e, "."));
      }
  }

  /**
   * This module serves as the "collision detection" mechanism for Vest.
   * It is used to ensure that tests are not called in a different order than
   * they were called in the previous run.
   * If they are, it will throw a deferred error unless explicitly allowed.
   *
   * For now it seems pretty safe, and it covers most common use cases, but it can
   * be improved in the future both in terms of performance and scenarios it covers.
   */
  // eslint-disable-next-line max-statements, max-lines-per-function
  function useTestAtCursor(newTestObject) {
      var testObjects = useTestObjects()[0];
      var prevTests = testObjects.prev;
      if (vestUtils.isEmpty(prevTests)) {
          useSetTestAtCursor(newTestObject);
          return newTestObject;
      }
      var prevTest = useGetTestAtCursor(prevTests);
      if (!vestUtils.isNullish(newTestObject.key)) {
          var nextTest_1 = handleKeyTest(newTestObject.key, newTestObject);
          useSetTestAtCursor(nextTest_1);
          return nextTest_1;
      }
      if (testReorderDetected(prevTest, newTestObject)) {
          throwTestOrderError(prevTest, newTestObject);
          removeAllNextTestsInIsolate();
          // Need to see if this has any effect at all.
          prevTest = null;
      }
      var nextTest = vestUtils.defaultTo(prevTest, newTestObject);
      useSetTestAtCursor(nextTest);
      return nextTest;
  }
  function removeAllNextTestsInIsolate() {
      var cursorAt = useCursor().current();
      // We actually don't mind mutating the state directly (as can be seen above). There is no harm in it
      // since we're only touching the "prev" state. The reason we still use the setter function is
      // to prevent future headaches if we ever do need to rely on prev-state immutability.
      useSetTests(function (current) {
          current.splice(cursorAt);
          return current;
      });
  }
  function useSetTestAtCursor(testObject) {
      var cursorPath = useCurrentPath();
      useSetTests(function (tests) {
          return vestUtils.nestedArray.setValueAtPath(tests, cursorPath, testObject);
      });
  }
  function useGetTestAtCursor(tests) {
      var cursorPath = useCurrentPath();
      return vestUtils.nestedArray.valueAtPath(tests, cursorPath);
  }
  function testReorderDetected(prevTest, newTest) {
      return vestUtils.isNotEmpty(prevTest) && !isSameProfileTest(prevTest, newTest);
  }
  function throwTestOrderError(prevTest, newTestObject) {
      if (shouldAllowReorder()) {
          return;
      }
      vestUtils.deferThrow("Vest Critical Error: Tests called in different order than previous run.\n    expected: ".concat(prevTest.fieldName, "\n    received: ").concat(newTestObject.fieldName, "\n    This can happen on one of two reasons:\n    1. You're using if/else statements to conditionally select tests. Instead, use \"skipWhen\".\n    2. You are iterating over a list of tests, and their order changed. Use \"each\" and a custom key prop so that Vest retains their state."));
  }
  function handleKeyTest(key, newTestObject) {
      var prevTestByKey = usePrevTestByKey(key);
      var nextTest = newTestObject;
      if (prevTestByKey) {
          nextTest = prevTestByKey;
      }
      useRetainTestKey(key, nextTest);
      return nextTest;
  }

  // eslint-disable-next-line max-statements
  function registerPrevRunTest(testObject) {
      var cursor = useCursor();
      if (shouldSkipBasedOnMode(testObject)) {
          testObject.skip();
          useTestAtCursor(testObject);
          cursor.next();
          return testObject;
      }
      var prevRunTest = useTestAtCursor(testObject);
      if (inActiveOmitWhen() || optionalFiedIsApplied(testObject.fieldName)) {
          prevRunTest.omit();
          cursor.next();
          return prevRunTest;
      }
      if (isExcluded(testObject)) {
          // We're forcing skipping the pending test
          // if we're directly within a skipWhen block
          // This mostly means that we're probably giving
          // up on this async test intentionally.
          prevRunTest.skip(isExcludedIndividually());
          cursor.next();
          return prevRunTest;
      }
      cancelOverriddenPendingTest(prevRunTest, testObject);
      useSetTestAtCursor(testObject);
      registerTestObjectByTier(testObject);
      cursor.next();
      return testObject;
  }
  function registerTestObjectByTier(testObject) {
      if (testObject.isUntested()) {
          registerTest(testObject);
      }
      else if (vestUtils.isPromise(testObject.asyncTest)) {
          testObject.setPending();
          runAsyncTest(testObject);
      }
  }

  /* eslint-disable jest/valid-title */
  function testMemo(test) {
      var cache = vestUtils.cache(10); // arbitrary cache size
      function memo(fieldName) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          var cursorAt = useCursor().current();
          var _a = args.reverse(), deps = _a[0], testFn = _a[1], msg = _a[2];
          // Implicit dependency for more specificity
          var dependencies = [useSuiteId(), fieldName, cursorAt].concat(deps);
          var cached = cache.get(dependencies);
          if (vestUtils.isNull(cached)) {
              // cache miss
              return cache(dependencies, function () { return test(fieldName, msg, testFn); });
          }
          if (cached[1].isCanceled()) {
              // cache hit, but test is canceled
              cache.invalidate(dependencies);
              return cache(dependencies, function () { return test(fieldName, msg, testFn); });
          }
          return registerPrevRunTest(cached[1]);
      }
      return memo;
  }

  function testBase(fieldName) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
      }
      var _a = (vestUtils.isFunction(args[1]) ? args : __spreadArray([undefined], args, true)), message = _a[0], testFn = _a[1], key = _a[2];
      vestUtils.invariant(vestUtils.isStringValue(fieldName), incompatibleParamsError('fieldName', 'string'));
      vestUtils.invariant(vestUtils.isFunction(testFn), incompatibleParamsError('Test callback', 'function'));
      var context$1 = context.useX();
      var testObject = new VestTest(fieldName, testFn, {
          message: message,
          groupName: context$1.groupName,
          key: key
      });
      return registerPrevRunTest(testObject);
  }
  /**
   * Represents a single case in a validation suite.
   *
   * @example
   *
   * test("username", "Username is required", () => {
   *  enforce(data.username).isNotBlank();
   * });
   */
  var test = vestUtils.assign(testBase, {
      memo: testMemo(testBase)
  });
  function incompatibleParamsError(name, expected) {
      return "Incompatible params passed to test function. ".concat(name, " must be a ").concat(expected);
  }

  var ERROR_OUTSIDE_OF_TEST = "warn hook called outside of a test callback. It won't have an effect."
      ;
  /**
   * Sets a running test to warn only mode.
   */
  function warn() {
      var ctx = context.useX('warn ' + ERROR_HOOK_CALLED_OUTSIDE);
      vestUtils.invariant(ctx.currentTest, ERROR_OUTSIDE_OF_TEST);
      ctx.currentTest.warn();
  }

  var VERSION = "4.6.11";

  Object.defineProperty(exports, 'enforce', {
    enumerable: true,
    get: function () { return n4s.enforce; }
  });
  exports.VERSION = VERSION;
  exports.context = context;
  exports.create = create;
  exports.each = each;
  exports.eager = eager;
  exports.group = group;
  exports.include = include;
  exports.omitWhen = omitWhen;
  exports.only = only;
  exports.optional = optional;
  exports.skip = skip;
  exports.skipWhen = skipWhen;
  exports.suiteSelectors = suiteSelectors;
  exports.test = test;
  exports.warn = warn;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
